import {
  DestroyRef,
  Injectable,
  Signal,
  WritableSignal,
  computed,
  inject,
  signal,
} from '@angular/core';
import { Observable } from 'rxjs';
import { ulid } from 'ulid';
import { Endpoints } from '../util/api-types';
import {
  LOCAL_CREATED_AT,
  LOCAL_GAME_ID,
  LOCAL_PLAYER_PREFIX,
  LOCAL_SESSION_ID,
} from '../util/constants';
import { Game } from '../util/game-types';
import { Player, PlayerForm } from '../util/player-types';
import { SessionStorageKeys } from '../util/session-storage-types';
import { OmitAutogeneratedProperties } from '../util/utility-types';
import { ApiService } from './api.service';
import { GameService } from './game.service';
import { SessionStorageService } from './session-storage.service';
import { WebSocketService } from './web-socket.service';

@Injectable({
  providedIn: 'root',
})
export class PlayerService {
  private readonly apiService = inject(ApiService);
  private readonly gameService = inject(GameService);
  private readonly sessionStorageService = inject(SessionStorageService);
  private readonly webSocketService = inject(WebSocketService);
  private readonly destroyRef = inject(DestroyRef);

  readonly game = this.gameService.game;

  private readonly localPlayers: WritableSignal<Player[]>;
  private readonly allOnlinePlayers: WritableSignal<Player[]>;
  private readonly connectedAndSortedOnlinePlayers = computed(() =>
    this.allOnlinePlayers(),
  );
  readonly players = computed(() => {
    const selectedPlayers =
      this.game().id === LOCAL_GAME_ID
        ? this.localPlayers()
        : this.connectedAndSortedOnlinePlayers();

    return selectedPlayers;
  });

  readonly playerId: WritableSignal<Player['id'] | null>;

  readonly player: Signal<Player> = computed(
    () =>
      this.players().find((player) => player.id === this.playerId()) ?? {
        id: '',
        name: '',
        color: '',
        gameId: LOCAL_GAME_ID,
        position: -1,
        createdAt: LOCAL_CREATED_AT,
        sessionId: null,
      },
  );

  readonly activePlayerId: WritableSignal<Player['id'] | undefined> =
    signal(undefined);

  readonly nextPlayer = computed(() => {
    const players = this.players();

    if (!players) {
      return;
    }

    const activePlayerIndex = players.findIndex(
      (player) => player.id === this.activePlayerId(),
    );

    if (activePlayerIndex === -1 || activePlayerIndex === players.length - 1) {
      return players[0];
    }

    return players[activePlayerIndex + 1];
  });

  constructor() {
    this.localPlayers = signal(
      (this.sessionStorageService.getItem(SessionStorageKeys.Players) ??
        []) as Player[],
    );
    this.playerId = signal(
      this.sessionStorageService.getItem(SessionStorageKeys.PlayerId) as
        | Player['id']
        | null,
    );
    this.allOnlinePlayers = signal([]);
    // const savedGame = this.game();
    // this.getOnlinePlayers(savedGame.id);
    // this.webSocketService.messages$
    //   .pipe(takeUntilDestroyed(this.destroyRef))
    //   .subscribe((message) => this.handleMessage(message));
  }

  // Online Player Methods
  createOnlinePlayer(
    playerForm: OmitAutogeneratedProperties<Player>,
  ): Observable<Player> {
    return this.apiService.post<Player>(Endpoints.PLAYER, playerForm);
  }

  getOnlinePlayerById(playerId: Player['id']): Observable<Player | null> {
    return this.apiService.get<Player | null>([Endpoints.PLAYER, playerId]);
  }

  getOnlinePlayersByGameId(gameId: Game['id']): Observable<Player[]> {
    return this.apiService.get<Player[]>(Endpoints.PLAYER, {
      gameId,
    });
  }

  updateOnlinePlayer(
    playerId: Player['id'],
    playerUpdates: Partial<Player>,
  ): Observable<Player | null> {
    return this.apiService.update<Player | null>(
      [Endpoints.PLAYER, playerId],
      playerUpdates,
    );
  }

  deleteOnlinePlayer(playerId: Player['id']): Observable<Player | null> {
    return this.apiService.delete<Player | null>([Endpoints.PLAYER, playerId]);
  }

  reorderOnlinePlayers(gameId: Game['id'], playerIds: Player['id'][]) {
    return this.apiService.update<Player[]>(
      [Endpoints.PLAYER, 'reorder', gameId],
      playerIds,
    );
  }

  clearOnlinePlayers() {
    this.allOnlinePlayers.set([]);
  }

  leaveOnlineGame() {
    const player = this.player();

    if (player) {
      this.deleteOnlinePlayer(player.id);
    }

    this.webSocketService.unsubscribeAll();
  }

  changeActiveOnlinePlayer(nextPlayerId?: Player['id']) {
    const activePlayerId = this.changeActivePlayer(nextPlayerId);
  }

  // Local Player Methods - these treat session storage as a "local" database
  createLocalPlayer(playerForm: PlayerForm) {
    const localPlayers = (this.sessionStorageService.getItem(
      SessionStorageKeys.Players,
    ) ?? []) as Player[];

    const newPlayer = {
      ...playerForm,
      id: `${LOCAL_PLAYER_PREFIX}${ulid()}`,
      position: localPlayers.length
        ? Math.max(...localPlayers.map((player) => player.position)) + 1
        : 0,
      gameId: LOCAL_GAME_ID,
      sessionId: LOCAL_SESSION_ID,
      createdAt: LOCAL_CREATED_AT,
    };

    localPlayers.push(newPlayer);

    this.sessionStorageService.setItem(
      SessionStorageKeys.Players,
      localPlayers,
    );

    return newPlayer;
  }

  updateLocalPlayer(playerId: Player['id'], playerUpdates: Partial<Player>) {
    const localPlayers = (this.sessionStorageService.getItem(
      SessionStorageKeys.Players,
    ) ?? []) as Player[];

    const updatedLocalPlayers = localPlayers.map((player) =>
      player.id === playerId ? { ...player, ...playerUpdates } : player,
    );

    this.sessionStorageService.setItem(
      SessionStorageKeys.Players,
      updatedLocalPlayers,
    );

    return updatedLocalPlayers.find((player) => player.id === playerId);
  }

  getLocalPlayersFromSessionStorage(): Player[] {
    return (this.sessionStorageService.getItem(SessionStorageKeys.Players) ??
      []) as Player[];
  }

  deleteLocalPlayer(playerId: Player['id']): Player | undefined {
    const localPlayers = (this.sessionStorageService.getItem(
      SessionStorageKeys.Players,
    ) ?? []) as Player[];

    const deletedPlayer = localPlayers.find((player) => player.id === playerId);

    const updatedLocalPlayers = localPlayers.filter(
      (player) => player.id !== playerId,
    );

    this.sessionStorageService.setItem(
      SessionStorageKeys.Players,
      updatedLocalPlayers,
    );

    return deletedPlayer;
  }

  reorderLocalPlayers(playerIds: Player['id'][]) {
    const reorderedLocalPlayers = (this.sessionStorageService.getItem(
      SessionStorageKeys.Players,
    ) ?? []) as Player[];

    reorderedLocalPlayers.forEach((player) => {
      player.position = playerIds.findIndex(
        (playerId) => playerId === player.id,
      );
    });

    this.sessionStorageService.setItem(
      SessionStorageKeys.Players,
      reorderedLocalPlayers,
    );

    return reorderedLocalPlayers;
  }

  changeActiveLocalPlayer(nextPlayerId?: Player['id']) {
    this.changeActivePlayer(nextPlayerId);
  }

  private changeActivePlayer(nextPlayerId?: Player['id']) {
    const players = this.players();

    if (!players) {
      return;
    }

    if (this.activePlayerId() === undefined) {
      this.activePlayerId.set(players[0].id);
      return players[0].id;
    }

    if (nextPlayerId !== undefined) {
      this.activePlayerId.set(nextPlayerId);
      return nextPlayerId;
    }

    const currentPlayerIndex = players.findIndex(
      (player) => player.id === this.activePlayerId(),
    );

    const nextPlayerIndex =
      currentPlayerIndex + 1 >= players.length ? 0 : currentPlayerIndex + 1;

    this.activePlayerId.set(players[nextPlayerIndex].id);

    return players[nextPlayerIndex].id;
  }
}
