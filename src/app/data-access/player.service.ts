import {
  computed,
  effect,
  inject,
  Injectable,
  signal,
  WritableSignal,
} from '@angular/core';
import { LocalStorageService } from './local-storage.service';
import {
  LocalStorageKeys,
  OmitAutogeneratedProperties,
  PlayerModel,
} from '../shared/custom-types';
import { moveItemInArray } from '@angular/cdk/drag-drop';
import { ulid } from 'ulid';
import { ApiService } from './api.service';
import { GameService } from './game.service';

@Injectable({
  providedIn: 'root',
})
export class PlayerService {
  private readonly localStorageService = inject(LocalStorageService);
  private readonly apiService = inject(ApiService);
  private readonly gameService = inject(GameService);

  readonly localPlayers: WritableSignal<PlayerModel[]>;
  readonly activePlayerId: WritableSignal<PlayerModel['id']>;

  readonly _player: WritableSignal<PlayerModel | undefined> = signal(undefined);
  readonly player = computed(() => this._player());

  readonly hostPlayerId = computed(() => this.gameService.game().hostPlayerId);
  readonly playerIsHost = computed(() => {
    const playerId = this.player()?.id;

    return playerId ? playerId === this.hostPlayerId() : false;
  });

  constructor() {
    this.localPlayers = signal(
      (this.localStorageService.getItem(LocalStorageKeys.Players) ??
        []) as PlayerModel[]
    );
    this.activePlayerId = signal(this.localPlayers()[0]?.id);
  }

  readonly nextPlayer = computed(() => {
    const activePlayerIndex = this.localPlayers().findIndex(
      (player) => player.id === this.activePlayerId()
    );

    if (
      activePlayerIndex === -1 ||
      activePlayerIndex === this.localPlayers().length - 1
    ) {
      return this.localPlayers()[0];
    }

    return this.localPlayers()[activePlayerIndex + 1];
  });

  // update local storage whenever players array changes
  private readonly localStoragePlayerUpdateEffect = effect(() =>
    this.localStorageService.setItem(
      LocalStorageKeys.Players,
      this.localPlayers()
    )
  );

  createLocalPlayer(newPlayer: OmitAutogeneratedProperties<PlayerModel>) {
    const newId = ulid();
    this.localPlayers.update((players) => [
      ...players,
      { id: newId, ...newPlayer },
    ]);
  }

  updatePlayer(
    id: string,
    updatedPlayer: Partial<OmitAutogeneratedProperties<PlayerModel>>
  ) {
    this.localPlayers.update((players) =>
      players.map((player) =>
        // only override properties declared in updatedPlayer
        player.id === id ? { ...player, ...updatedPlayer } : player
      )
    );
  }

  deletePlayer(id: string) {
    this.localPlayers.update((players) =>
      players.filter((player) => player.id !== id)
    );
    this.updatePlayerPositions();
  }

  swapPlayers(playerIndex1: number, playerIndex2: number) {
    this.localPlayers.update((players) => {
      const reorderedPlayers = players;
      moveItemInArray(reorderedPlayers, playerIndex1, playerIndex2);
      return reorderedPlayers;
    });
    this.updatePlayerPositions();
  }

  updatePlayerPositions() {
    this.localPlayers.update((players) =>
      players.map((player, index) => ({ ...player, position: index }))
    );
  }

  changeActivePlayer(nextPlayerId?: PlayerModel['id']) {
    if (this.activePlayerId() === undefined) {
      this.activePlayerId.set(this.localPlayers()[0].id);
      return;
    }

    if (nextPlayerId !== undefined) {
      this.activePlayerId.set(nextPlayerId);
      return;
    }

    const currentPlayerIndex = this.localPlayers().findIndex(
      (player) => player.id === this.activePlayerId()
    );

    const nextPlayerIndex =
      currentPlayerIndex + 1 >= this.localPlayers().length
        ? 0
        : currentPlayerIndex + 1;

    this.activePlayerId.set(this.localPlayers()[nextPlayerIndex].id);
  }

  async createPlayer(player: PlayerModel) {
    const newPlayer = await this.apiService.createPlayer(player);

    if (newPlayer) {
      this._player.set(newPlayer);
    }

    return newPlayer;
  }
}
